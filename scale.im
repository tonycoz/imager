#define IMAGER_NO_CONTEXT

#include "imager.h"
#include "imageri.h"
#include "immacros.h"

/*
 * i_scale_mixing() is based on code contained in pnmscale.c, part of
 * the netpbm distribution.  No code was copied from pnmscale but
 * the algorthm was and for this I thank the netpbm crew.
 *
 * Tony
 */

/* pnmscale.c - read a portable anymap and scale it
**
** Copyright (C) 1989, 1991 by Jef Poskanzer.
**
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted, provided
** that the above copyright notice appear in all copies and that both that
** copyright notice and this permission notice appear in supporting
** documentation.  This software is provided "as is" without express or
** implied warranty.
**
*/

static void
zero_row(double *row, i_img_dim width, int channels);

#code
static void
IM_SUFFIX(accum_output_row)(double *accum, double fraction, IM_LIN_SAMPLE_T const *in,
			    i_img_dim width, int channels, int has_alpha);
static void
IM_SUFFIX(horizontal_scale)(IM_LIN_SAMPLE_T *out, i_img_dim out_width,
                            double const *in, i_img_dim in_width,
                            int channels, int has_alpha);
#/code

/*
=item i_scale_mixing

Returns a new image scaled to the given size.

Unlike i_scale_axis() this does a simple coverage of pixels from
source to target and doesn't resample.

Adapted from pnmscale.

=cut
*/
i_img *
i_scale_mixing(i_img *src, i_img_dim x_out, i_img_dim y_out) {
  dIMCTXim(src);
  i_img *result = NULL;
  double *accum_row = NULL;
  i_img_dim x, y;
  int ch;
  size_t accum_row_bytes;
  double rowsleft, fracrowtofill;
  i_img_dim rowsread;
  double y_scale;
  int alpha_chan;
  int has_alpha = i_img_alpha_channel(src, &alpha_chan);
  int color_channels = i_img_color_channels(src);

  im_log((aIMCTX, 1, "i_scale_mixing(src %p, out(" i_DFp "))\n", 
	  src, i_DFcp(x_out, y_out)));

  i_clear_error();

  if (x_out <= 0) {
    i_push_errorf(0, "output width %" i_DF " invalid", i_DFc(x_out));
    return NULL;
  }
  if (y_out <= 0) {
    i_push_errorf(0, "output height %" i_DF " invalid", i_DFc(y_out));
    return NULL;
  }

  if (x_out == src->xsize && y_out == src->ysize) {
    return i_copy(src);
  }

  y_scale = y_out / (double)src->ysize;

  accum_row_bytes = sizeof(double) * src->channels * src->xsize;
  im_log((aIMCTX, 1, " row bytes %zu dblsize %zu channels %d xsize %zd div %zd\n", accum_row_bytes,
	  sizeof(double), src->channels, src->xsize, accum_row_bytes / sizeof(double) / src->channels));
  if (accum_row_bytes / sizeof(double) / src->channels != src->xsize) {
    i_push_error(0, "integer overflow allocating accumulator row buffer");
    return NULL;
  }

  result = i_sametype_chans(src, x_out, y_out, src->channels);
  if (!result)
    return NULL;

  accum_row  = mymalloc(accum_row_bytes);

#code src->bits <= 8
  IM_LIN_SAMPLE_T *in_row = NULL;
  IM_LIN_SAMPLE_T *xscale_row = NULL;
  size_t in_row_bytes, out_row_bytes;

  in_row_bytes = sizeof(IM_LIN_SAMPLE_T) * src->channels * src->xsize;
  if (in_row_bytes / sizeof(IM_LIN_SAMPLE_T) / src->channels != src->xsize) {
    myfree(accum_row);
    i_img_destroy(result);
    i_push_error(0, "integer overflow allocating input row buffer");
    return NULL;
  }
  out_row_bytes = sizeof(IM_LIN_SAMPLE_T) * src->channels * x_out;
  if (out_row_bytes / sizeof(IM_LIN_SAMPLE_T) / src->channels != x_out) {
    myfree(accum_row);
    i_img_destroy(result);
    i_push_error(0, "integer overflow allocating output row buffer");
    return NULL;
  }

  in_row     = mymalloc(in_row_bytes);
  xscale_row = mymalloc(out_row_bytes);

  rowsread = 0;
  rowsleft = 0.0;
  for (y = 0; y < y_out; ++y) {
    if (y_out == src->ysize) {
      /* no vertical scaling, just load it */
      i_gslinf(src, 0, src->xsize, y, accum_row, NULL, src->channels);

      /* alpha adjust if needed */
      if (has_alpha) {
	double *outp = accum_row;
	for (x = 0; x < src->xsize; ++x) {
	  double alpha = outp[alpha_chan] / IM_SAMPLE_MAX;
	  for (ch = 0; ch < color_channels; ++ch) {
	    outp[ch] *= alpha;
	  }
	  outp += src->channels;
	}
      }
    }
    else {
      fracrowtofill = 1.0;
      zero_row(accum_row, src->xsize, src->channels);
      while (fracrowtofill > 0) {
	if (rowsleft <= 0) {
	  if (rowsread < src->ysize) {
	    IM_GSLIN(src, 0, src->xsize, rowsread, in_row, NULL, src->channels);
	    ++rowsread;
	  }
	  /* else just use the last row read */

	  rowsleft = y_scale;
	}
	if (rowsleft < fracrowtofill) {
	  IM_SUFFIX(accum_output_row)(accum_row, rowsleft, in_row, 
                                      src->xsize, src->channels, has_alpha);
	  fracrowtofill -= rowsleft;
	  rowsleft = 0;
	}
	else {
	  IM_SUFFIX(accum_output_row)(accum_row, fracrowtofill, in_row, 
                                      src->xsize, src->channels, has_alpha);
	  rowsleft -= fracrowtofill;
	  fracrowtofill = 0;
	}
      }
    }
    /* we've accumulated a vertically scaled row */
    if (x_out == src->xsize) {
#ifdef IM_EIGHT_BIT
      i_img_dim x;
      int ch;
      /* no need to scale, but we need to convert it */
      if (has_alpha) {
	double *inp = accum_row;
	IM_LIN_SAMPLE_T *outp = xscale_row;
	for (x = 0; x < x_out; ++x) {
	  double alpha = inp[alpha_chan] / IM_SAMPLE_MAX;
	  if (alpha) {
	    for (ch = 0; ch < color_channels; ++ch) {
	      int val = inp[ch] / alpha + 0.5;
	      outp[ch] = IM_LIN_LIMIT(val);
	    }
	    outp[alpha_chan] = IM_LIN_LIMIT(*inp+0.5);
	  }
	  else {
	    /* rather than leaving any color data as whatever was
	       originally in the buffer, set it to black.  This isn't
	       any more correct, but it gives us more compressible
	       image data.
	       RT #32324
	    */
	    for (ch = 0; ch <= color_channels; ++ch) {
	      outp[ch] = 0;
	    }
	  }
	  inp += src->channels;
	  outp += src->channels;
	}
      }
      else {
	double *inp = accum_row;
	IM_LIN_SAMPLE_T *outp = xscale_row;
	for (x = 0; x < x_out; ++x) {
	  for (ch = 0; ch < color_channels; ++ch)
	    *outp++ = IM_LIN_LIMIT(0.5 + *inp++);
	}
      }
      IM_PSLIN(result, 0, x_out, y, xscale_row, NULL, src->channels);
#else
      IM_PSLIN(result, 0, x_out, y, accum_row, NULL, src->channels);
#endif
    }
    else {
      IM_SUFFIX(horizontal_scale)(xscale_row, x_out, accum_row, 
                                  src->xsize, src->channels, has_alpha);
      IM_PSLIN(result, 0, x_out, y, xscale_row, NULL, src->channels);
    }
  }
  myfree(in_row);
  myfree(xscale_row);
#/code
  myfree(accum_row);

  return result;
}

static void
zero_row(double *row, i_img_dim width, int channels) {
  double *outp = row;
  i_img_dim count = width * channels;
  i_img_dim i;

  /* with IEEE floats we could just use memset() but that's not
     safe in general under ANSI C.
     memset() is slightly faster.
  */
  for (i = 0; i < count; ++i)
    *outp++ = 0;
}

#code

static void
IM_SUFFIX(accum_output_row)(double *accum, double fraction, IM_LIN_SAMPLE_T const *in,
			    i_img_dim width, int channels, int has_alpha) {
  i_img_dim x;
  int ch;
  double *paccum = accum;
  IM_LIN_SAMPLE_T const *pin = in;

  /* it's tempting to change this into a pointer iteration loop but
     modern CPUs do the indexing as part of the instruction */
  if (has_alpha) {
    for (x = 0; x < width; ++x) {
      double alpha = fraction * pin[channels-1];
      for (ch = 0; ch < channels-1; ++ch) {
	paccum[ch] += pin[ch] * alpha / IM_SAMPLE_MAX;
      }
      paccum[channels-1] += alpha;
      paccum += channels;
      pin += channels;
    }
  }
  else {
    for (x = 0; x < width; ++x) {
      for (ch = 0; ch < channels; ++ch) {
	paccum[ch] += pin[ch] * fraction;
      }
      paccum += channels;
      pin += channels;
    }
  }
}

static void
IM_SUFFIX(horizontal_scale)(IM_LIN_SAMPLE_T *out, i_img_dim out_width,
			    double const *in, i_img_dim in_width,
			    int channels, int has_alpha) {
  double frac_col_to_fill, frac_col_left;
  i_img_dim in_x;
  i_img_dim out_x;
  double x_scale = (double)out_width / in_width;
  int ch;
  double accum[MAXCHANNELS] = { 0 };
  double const *pin = in;
  IM_LIN_SAMPLE_T *pout = out;
  
  frac_col_to_fill = 1.0;
  out_x = 0;
  for (in_x = 0; in_x < in_width; ++in_x) {
    frac_col_left = x_scale;
    while (frac_col_left >= frac_col_to_fill) {
      for (ch = 0; ch < channels; ++ch)
	accum[ch] += frac_col_to_fill * pin[ch];

      if (has_alpha) {
	int alpha_chan = channels - 1;
	double alpha = accum[alpha_chan] / IM_SAMPLE_MAX;
	if (alpha) {
	  for (ch = 0; ch < alpha_chan; ++ch) {
	    IM_WORK_T val = IM_ROUND(accum[ch] / alpha);
	    pout[ch] = IM_LIN_LIMIT(val);
	  }
	}
	else {
	  for (ch = 0; ch < alpha_chan; ++ch) {
	    /* See RT #32324 (and mention above) */
	    pout[ch] = 0;
	  }
	}
	pout[alpha_chan] = IM_LIN_LIMIT(IM_ROUND(accum[alpha_chan]));
      }
      else {
	for (ch = 0; ch < channels; ++ch) {
	  IM_WORK_T val = IM_ROUND(accum[ch]);
	  pout[ch] = IM_LIN_LIMIT(val);
	}
      }
      for (ch = 0; ch < channels; ++ch)
	accum[ch] = 0;
      frac_col_left -= frac_col_to_fill;
      frac_col_to_fill = 1.0;
      ++out_x;
      pout += channels;
    }

    if (frac_col_left > 0) {
      for (ch = 0; ch < channels; ++ch) {
	accum[ch] += frac_col_left * pin[ch];
      }
      frac_col_to_fill -= frac_col_left;
    }
    pin += channels;
  }

  if (out_x < out_width-1 || out_x > out_width) {
    i_fatal(3, "Internal error: out_x #" i_DF " out of range (width %" i_DF ")", i_DFc(out_x),
            i_DFc(out_width));
  }
  
  if (out_x < out_width) {
    pin -= channels;
    for (ch = 0; ch < channels; ++ch) {
      accum[ch] += frac_col_to_fill * pin[ch];
    }
    if (has_alpha) {
      int alpha_chan = channels - 1;
      double alpha = accum[alpha_chan] / IM_SAMPLE_MAX;
      IM_WORK_T pre_limit;
      if (alpha) {
	for (ch = 0; ch < alpha_chan; ++ch) {
	  IM_WORK_T val = IM_ROUND(accum[ch] / alpha);
	  pout[ch] = IM_LIN_LIMIT(val);
	}
      }
      else {
	for (ch = 0; ch < alpha_chan; ++ch) {
	  /* See RT #32324 (and mention above) */
	  pout[ch] = 0;
	}
      }
      pre_limit = IM_ROUND(accum[alpha_chan]);
      pout[alpha_chan] = IM_LIN_LIMIT(pre_limit);
    }
    else {
      for (ch = 0; ch < channels; ++ch) {
	IM_WORK_T val = IM_ROUND(accum[ch]);
	pout[ch] = IM_LIN_LIMIT(val);
      }
    }
  }
}

#/code

/*

http://en.wikipedia.org/wiki/Lanczos_resampling

*/

#define XAXIS 0
#define YAXIS 1
#define XYAXIS 2

#define minmax(a,b,i) ( ((a>=i)?a: ( (b<=i)?b:i   )) )

static
float
Lanczos(float x) {
  float PIx, PIx2;
  
  PIx = PI * x;
  PIx2 = PIx / 2.0;
  
  if ((x >= 2.0) || (x <= -2.0)) return (0.0);
  else if (x == 0.0) return (1.0);
  else return(sin(PIx) / PIx * sin(PIx2) / PIx2);
}


/*
=item i_scaleaxis(im, value, axis)

Returns a new image object which is I<im> scaled by I<value> along
wither the x-axis (I<axis> == 0) or the y-axis (I<axis> == 1).

=cut
*/

i_img*
i_scaleaxis(i_img *im, double Value, int Axis) {
  i_img_dim hsize, vsize, i, j, k, l, lMax, iEnd, jEnd;
  i_img_dim LanczosWidthFactor;
  float *l0, *l1;
  double OldLocation;
  i_img_dim T; 
  double t;
  float F, PictureValue[MAXCHANNELS];
  int psave;
  i_img *new_img;
  int has_alpha = i_img_has_alpha(im);
  int color_chans = i_img_color_channels(im);
  int work_channels = color_chans + !!has_alpha;
  dIMCTXim(im);

  i_clear_error();
  im_log((aIMCTX, 1,"i_scaleaxis(im %p,Value %.2f,Axis %d)\n",im,Value,Axis));

  if (Axis == XAXIS) {
    hsize = (i_img_dim)(0.5 + im->xsize * Value);
    if (hsize < 1) {
      hsize = 1;
      Value = 1.0 / im->xsize;
    }
    vsize = im->ysize;
    
    jEnd = hsize;
    iEnd = vsize;
  } else {
    hsize = im->xsize;
    vsize = (i_img_dim)(0.5 + im->ysize * Value);

    if (vsize < 1) {
      vsize = 1;
      Value = 1.0 / im->ysize;
    }

    jEnd = vsize;
    iEnd = hsize;
  }
  
  new_img = i_img_8_new(hsize, vsize, im->channels);
  if (!new_img) {
    i_push_error(0, "cannot create output image");
    return NULL;
  }
  
  /* 1.4 is a magic number, setting it to 2 will cause rather blurred images */
  LanczosWidthFactor = (Value >= 1) ? 1 : (i_img_dim) (1.4/Value); 
  lMax = LanczosWidthFactor << 1;
  
  l0 = mymalloc(lMax * sizeof(float));
  l1 = mymalloc(lMax * sizeof(float));
  
  for (j=0; j<jEnd; j++) {
    OldLocation = ((double) j) / Value;
    T = (i_img_dim) (OldLocation);
    F = OldLocation - T;
    
    for (l = 0; l<lMax; l++) {
      l0[lMax-l-1] = Lanczos(((float) (lMax-l-1) + F) / (float) LanczosWidthFactor);
      l1[l]        = Lanczos(((float) (l+1)      - F) / (float) LanczosWidthFactor);
    }
    
    /* Make sure filter is normalized */
    t = 0.0;
    for(l=0; l<lMax; l++) {
      t+=l0[l];
      t+=l1[l];
    }
    t /= (double)LanczosWidthFactor;
    
    for(l=0; l<lMax; l++) {
      l0[l] /= t;
      l1[l] /= t;
    }

    if (Axis == XAXIS) {
      
      for (i=0; i<iEnd; i++) {
	i_sample16_t val[MAXCHANNELS];
	
	for (k=0; k<im->channels; k++)
	  PictureValue[k] = 0.0;
	
	for (l=0; l<lMax; l++) {
	  i_sample16_t val1[MAXCHANNELS];
	  i_sample16_t val2[MAXCHANNELS];
	  i_img_dim mx = T-lMax+l+1;
	  i_img_dim Mx = T+l+1;
	  
	  mx = (mx < 0) ? 0 : mx;
	  Mx = (Mx >= im->xsize) ? im->xsize-1 : Mx;
	  
	  i_gslin(im, Mx, Mx+1, i, val1, NULL, work_channels);
	  i_gslin(im, mx, mx+1, i, val2, NULL, work_channels);

	  if (has_alpha) {
	    i_sample16_t alpha1 = val1[color_chans];
	    i_sample16_t alpha2 = val2[color_chans];
	    for (k=0; k < color_chans; k++) {
	      PictureValue[k] += l1[l]        * val1[k] * alpha1 / 65535;
	      PictureValue[k] += l0[lMax-l-1] * val2[k] * alpha2 / 65535;
	    }
	    PictureValue[color_chans] += l1[l] * val1[color_chans];
	    PictureValue[color_chans] += l0[lMax-l-1] * val2[color_chans];
	  }
	  else {
	    for (k=0; k<im->channels; k++) {
	      PictureValue[k] += l1[l]        * val1[k];
	      PictureValue[k] += l0[lMax-l-1] * val2[k];
	    }
	  }
	}

	if (has_alpha) {
	  float fa = PictureValue[color_chans] / LanczosWidthFactor;
	  i_sample16_t alpha = minmax(0, 65535, fa+0.5);
	  
	  if (alpha) {
	    for (k = 0; k < color_chans; ++k) {
	      psave = (int)(0.5+(PictureValue[k] / LanczosWidthFactor * 65535 / fa));
	      val[k]=minmax(0,65535,psave);
	    }
	    val[color_chans] = alpha;
	  }
	  else {
	    /* zero alpha, so the pixel has no color */
	    for (k = 0; k < im->channels; ++k)
	      val[k] = 0;
	  }
	}
	else {
	  for(k=0;k<im->channels;k++) {
	    psave = (int)(0.5+(PictureValue[k] / LanczosWidthFactor));
	    val[k]=minmax(0,65535,psave);
	  }
	}
	i_pslin(new_img, j, j+1, i, val, NULL, work_channels);
      }
      
    } else {
      
      for (i=0; i<iEnd; i++) {
	i_sample16_t val[MAXCHANNELS];
	
	for (k=0; k<im->channels; k++)
	  PictureValue[k] = 0.0;
	
	for (l=0; l < lMax; l++) {
	  i_img_dim mx = T-lMax+l+1;
	  i_img_dim Mx = T+l+1;
	  i_sample16_t val1[MAXCHANNELS];
	  i_sample16_t val2[MAXCHANNELS];
	  
	  mx = (mx < 0) ? 0 : mx;
	  Mx = (Mx >= im->ysize) ? im->ysize-1 : Mx;

	  i_gslin(im, i, i+1, Mx, val1, NULL, work_channels);
	  i_gslin(im, i, i+1, mx, val2, NULL, work_channels);
	  if (has_alpha) {
	    i_sample16_t alpha1 = val1[color_chans];
	    i_sample16_t alpha2 = val2[color_chans];
	    for (k=0; k < color_chans; k++) {
	      PictureValue[k] += l1[l]        * val1[k] * alpha1 / 65535;
	      PictureValue[k] += l0[lMax-l-1] * val2[k] * alpha2 / 65535;
	    }
	    PictureValue[color_chans] += l1[l] * val1[color_chans];
	    PictureValue[color_chans] += l0[lMax-l-1] * val2[color_chans];
	  }
	  else {
	    for (k=0; k<im->channels; k++) {
	      PictureValue[k] += l1[l]        * val1[k];
	      PictureValue[k] += l0[lMax-l-1] * val2[k];
	    }
	  }
	}
	if (has_alpha) {
	  float fa = PictureValue[color_chans] / LanczosWidthFactor;
	  i_sample16_t alpha = minmax(0, 65535, fa+0.5);
	  if (alpha) {
	    for (k = 0; k < color_chans; ++k) {
	      psave = (int)(0.5+(PictureValue[k] / LanczosWidthFactor * 65535 / fa));
	      val[k]=minmax(0,65535,psave);
	    }
	    val[color_chans] = alpha;
	  }
	  else {
	    for (k = 0; k < im->channels; ++k)
	      val[k] = 0;
	  }
	}
	else {
	  for(k=0;k<im->channels;k++) {
	    psave = (int)(0.5+(PictureValue[k] / LanczosWidthFactor));
	    val[k]=minmax(0,65535,psave);
	  }
	}
	i_pslin(new_img, i, i+1, j, val, NULL, work_channels);
      }
      
    }
  }
  myfree(l0);
  myfree(l1);

  im_log((aIMCTX, 1,"(%p) <- i_scaleaxis\n", new_img));

  return new_img;
}


/* 
=item i_scale_nn(im, scx, scy)

Scale by using nearest neighbor 
Both axes scaled at the same time since 
nothing is gained by doing it in two steps 

=cut
*/


i_img*
i_scale_nn(i_img *im, double scx, double scy) {

  i_img_dim nxsize,nysize,nx,ny;
  i_img *new_img;
  i_color val;
  dIMCTXim(im);

  im_log((aIMCTX, 1,"i_scale_nn(im %p,scx %.2f,scy %.2f)\n",im,scx,scy));

  nxsize = (i_img_dim) ((double) im->xsize * scx);
  if (nxsize < 1) {
    nxsize = 1;
    scx = 1.0 / im->xsize;
  }
  nysize = (i_img_dim) ((double) im->ysize * scy);
  if (nysize < 1) {
    nysize = 1;
    scy = 1.0 / im->ysize;
  }
  im_assert(scx != 0 && scy != 0);
    
  new_img=i_img_empty_ch(NULL,nxsize,nysize,im->channels);
  
  for(ny=0;ny<nysize;ny++) for(nx=0;nx<nxsize;nx++) {
    i_gpix(im,((double)nx)/scx,((double)ny)/scy,&val);
    i_ppix(new_img,nx,ny,&val);
  }

  im_log((aIMCTX, 1,"(%p) <- i_scale_nn\n",new_img));

  return new_img;
}

