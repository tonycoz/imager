#include "imager.h"
#include "imageri.h"

/*
 * i_scale_mixing() is based on code contained in pnmscale.c, part of
 * the netpbm distribution.  No code was copied from pnmscale but
 * the algorthm was and for this I thank the netpbm crew.
 *
 * Tony
 */

/* pnmscale.c - read a portable anymap and scale it
**
** Copyright (C) 1989, 1991 by Jef Poskanzer.
**
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted, provided
** that the above copyright notice appear in all copies and that both that
** copyright notice and this permission notice appear in supporting
** documentation.  This software is provided "as is" without express or
** implied warranty.
**
*/


static void
zero_row(double *row, i_img_dim width, int channels);

#code
static void
IM_SUFFIX(accum_output_row)(double *accum, double fraction, IM_SAMPLE_T const *in,
			    i_img_dim width, int channels, int has_alpha);
static void
IM_SUFFIX(horizontal_scale)(IM_SAMPLE_T *out, i_img_dim out_width, 
                            double const *in, i_img_dim in_width,
                            int channels, int has_alpha);
#/code

/*
=item i_scale_mixing

Returns a new image scaled to the given size.

Unlike i_scale_axis() this does a simple coverage of pixels from
source to target and doesn't resample.

Adapted from pnmscale.

=cut
*/
i_img *
i_scale_mixing(i_img *src, i_img_dim x_out, i_img_dim y_out) {
  i_img *result = NULL;
  double *accum_row = NULL;
  i_img_dim x, y;
  int ch;
  size_t accum_row_bytes;
  double rowsleft, fracrowtofill;
  i_img_dim rowsread;
  double y_scale;
  int alpha_chan;
  int has_alpha = i_img_alpha_channel(src, &alpha_chan);
  int color_channels = i_img_color_channels(src);

  mm_log((1, "i_scale_mixing(src %p, out(" i_DFp "))\n", 
	  src, i_DFcp(x_out, y_out)));

  i_clear_error();

  if (x_out <= 0) {
    i_push_errorf(0, "output width %" i_DF " invalid", i_DFc(x_out));
    return NULL;
  }
  if (y_out <= 0) {
    i_push_errorf(0, "output height %" i_DF " invalid", i_DFc(y_out));
    return NULL;
  }

  if (x_out == src->xsize && y_out == src->ysize) {
    return i_copy(src);
  }

  y_scale = y_out / (double)src->ysize;

  accum_row_bytes = sizeof(double) * src->channels * src->xsize;
  mm_log((1, " row bytes %zu dblsize %zu channels %d xsize %zd div %zd\n", accum_row_bytes,
	  sizeof(double), src->channels, src->xsize, accum_row_bytes / sizeof(double) / src->channels));
  if (accum_row_bytes / sizeof(double) / src->channels != src->xsize) {
    i_push_error(0, "integer overflow allocating accumulator row buffer");
    return NULL;
  }

  result = i_sametype_chans(src, x_out, y_out, src->channels);
  if (!result)
    return NULL;

  accum_row  = mymalloc(accum_row_bytes);

#code src->bits <= 8
  IM_SAMPLE_T *in_row = NULL;
  IM_SAMPLE_T *xscale_row = NULL;
  size_t in_row_bytes, out_row_bytes;

  in_row_bytes = sizeof(IM_SAMPLE_T) * src->channels * src->xsize;
  if (in_row_bytes / sizeof(IM_SAMPLE_T) / src->channels != src->xsize) {
    myfree(accum_row);
    i_img_destroy(result);
    i_push_error(0, "integer overflow allocating input row buffer");
    return NULL;
  }
  out_row_bytes = sizeof(IM_SAMPLE_T) * src->channels * x_out;
  if (out_row_bytes / sizeof(IM_SAMPLE_T) / src->channels != x_out) {
    myfree(accum_row);
    i_img_destroy(result);
    i_push_error(0, "integer overflow allocating output row buffer");
    return NULL;
  }

  in_row     = mymalloc(in_row_bytes);
  xscale_row = mymalloc(out_row_bytes);

  rowsread = 0;
  rowsleft = 0.0;
  for (y = 0; y < y_out; ++y) {
    if (y_out == src->ysize) {
      /* no vertical scaling, just load it */
      i_gsampf(src, 0, src->xsize, y, accum_row, NULL, src->channels);

      /* alpha adjust if needed */
      if (has_alpha) {
	double *outp = accum_row;
	for (x = 0; x < src->xsize; ++x) {
	  double alpha = outp[alpha_chan] / IM_SAMPLE_MAX;
	  for (ch = 0; ch < color_channels; ++ch) {
	    outp[ch] *= alpha;
	  }
	  outp += src->channels;
	}
      }
    }
    else {
      fracrowtofill = 1.0;
      zero_row(accum_row, src->xsize, src->channels);
      while (fracrowtofill > 0) {
	if (rowsleft <= 0) {
	  if (rowsread < src->ysize) {
	    IM_GSAMP(src, 0, src->xsize, rowsread, in_row, NULL, src->channels);
	    ++rowsread;
	  }
	  /* else just use the last row read */

	  rowsleft = y_scale;
	}
	if (rowsleft < fracrowtofill) {
	  IM_SUFFIX(accum_output_row)(accum_row, rowsleft, in_row, 
                                      src->xsize, src->channels, has_alpha);
	  fracrowtofill -= rowsleft;
	  rowsleft = 0;
	}
	else {
	  IM_SUFFIX(accum_output_row)(accum_row, fracrowtofill, in_row, 
                                      src->xsize, src->channels, has_alpha);
	  rowsleft -= fracrowtofill;
	  fracrowtofill = 0;
	}
      }
    }
    /* we've accumulated a vertically scaled row */
    if (x_out == src->xsize) {
#if IM_EIGHT_BIT
      i_img_dim x;
      int ch;
      /* no need to scale, but we need to convert it */
      if (has_alpha) {
	double *inp = accum_row;
	IM_SAMPLE_T *outp = xscale_row;
	for (x = 0; x < x_out; ++x) {
	  double alpha = inp[alpha_chan] / IM_SAMPLE_MAX;
	  if (alpha) {
	    for (ch = 0; ch < color_channels; ++ch) {
	      int val = inp[ch] / alpha + 0.5;
	      outp[ch] = IM_LIMIT(val);
	    }
	    outp[alpha_chan] = IM_LIMIT(*inp+0.5);
	  }
	  else {
	    /* rather than leaving any color data as whatever was
	       originally in the buffer, set it to black.  This isn't
	       any more correct, but it gives us more compressible
	       image data.
	       RT #32324
	    */
	    for (ch = 0; ch <= color_channels; ++ch) {
	      outp[ch] = 0;
	    }
	  }
	  inp += src->channels;
	  outp += src->channels;
	}
      }
      else {
	double *inp = accum_row;
	IM_SAMPLE_T *outp = xscale_row;
	for (x = 0; x < x_out; ++x) {
	  for (ch = 0; ch < color_channels; ++ch)
	    *outp++ = IM_LIMIT(0.5 + *inp++);
	}
      }
      IM_PSAMP(result, 0, x_out, y, xscale_row, NULL, src->channels);
#else
      IM_PSAMP(result, 0, x_out, y, accum_row, NULL, src->channels);
#endif
    }
    else {
      IM_SUFFIX(horizontal_scale)(xscale_row, x_out, accum_row, 
                                  src->xsize, src->channels, has_alpha);
      IM_PSAMP(result, 0, x_out, y, xscale_row, NULL, src->channels);
    }
  }
  myfree(in_row);
  myfree(xscale_row);
#/code
  myfree(accum_row);

  return result;
}

static void
zero_row(double *row, i_img_dim width, int channels) {
  double *outp = row;
  i_img_dim count = width * channels;
  i_img_dim i;

  /* with IEEE floats we could just use memset() but that's not
     safe in general under ANSI C.
     memset() is slightly faster.
  */
  for (i = 0; i < count; ++i)
    *outp++ = 0;
}

#code

static void
IM_SUFFIX(accum_output_row)(double *accum, double fraction, IM_SAMPLE_T const *in,
			    i_img_dim width, int channels, int has_alpha) {
  i_img_dim x;
  int ch;
  double *paccum = accum;
  IM_SAMPLE_T const *pin = in;

  /* it's tempting to change this into a pointer iteration loop but
     modern CPUs do the indexing as part of the instruction */
  if (has_alpha) {
    for (x = 0; x < width; ++x) {
      double alpha = fraction * pin[channels-1];
      for (ch = 0; ch < channels-1; ++ch) {
	paccum[ch] += pin[ch] * alpha / IM_SAMPLE_MAX;
      }
      paccum[channels-1] += alpha;
      paccum += channels;
      pin += channels;
    }
  }
  else {
    for (x = 0; x < width; ++x) {
      for (ch = 0; ch < channels; ++ch) {
	paccum[ch] += pin[ch] * fraction;
      }
      paccum += channels;
      pin += channels;
    }
  }
}

static void
IM_SUFFIX(horizontal_scale)(IM_SAMPLE_T *out, i_img_dim out_width, 
			    double const *in, i_img_dim in_width,
			    int channels, int has_alpha) {
  double frac_col_to_fill, frac_col_left;
  i_img_dim in_x;
  i_img_dim out_x;
  double x_scale = (double)out_width / in_width;
  int ch;
  double accum[MAXCHANNELS] = { 0 };
  double const *pin = in;
  IM_SAMPLE_T *pout = out;
  
  frac_col_to_fill = 1.0;
  out_x = 0;
  for (in_x = 0; in_x < in_width; ++in_x) {
    frac_col_left = x_scale;
    while (frac_col_left >= frac_col_to_fill) {
      for (ch = 0; ch < channels; ++ch)
	accum[ch] += frac_col_to_fill * pin[ch];

      if (has_alpha) {
	int alpha_chan = channels - 1;
	double alpha = accum[alpha_chan] / IM_SAMPLE_MAX;
	if (alpha) {
	  for (ch = 0; ch < alpha_chan; ++ch) {
	    IM_WORK_T val = IM_ROUND(accum[ch] / alpha);
	    pout[ch] = IM_LIMIT(val);
	  }
	}
	else {
	  for (ch = 0; ch < alpha_chan; ++ch) {
	    /* See RT #32324 (and mention above) */
	    pout[ch] = 0;
	  }
	}
	pout[alpha_chan] = IM_LIMIT(IM_ROUND(accum[alpha_chan]));
      }
      else {
	for (ch = 0; ch < channels; ++ch) {
	  IM_WORK_T val = IM_ROUND(accum[ch]);
	  pout[ch] = IM_LIMIT(val);
	}
      }
      for (ch = 0; ch < channels; ++ch)
	accum[ch] = 0;
      frac_col_left -= frac_col_to_fill;
      frac_col_to_fill = 1.0;
      ++out_x;
      pout += channels;
    }

    if (frac_col_left > 0) {
      for (ch = 0; ch < channels; ++ch) {
	accum[ch] += frac_col_left * pin[ch];
      }
      frac_col_to_fill -= frac_col_left;
    }
    pin += channels;
  }

  if (out_x < out_width-1 || out_x > out_width) {
    i_fatal(3, "Internal error: out_x #" i_DF " out of range (width %" i_DF ")", i_DFc(out_x),
            i_DFc(out_width));
  }
  
  if (out_x < out_width) {
    pin -= channels;
    for (ch = 0; ch < channels; ++ch) {
      accum[ch] += frac_col_to_fill * pin[ch];
    }
    if (has_alpha) {
      int alpha_chan = channels - 1;
      double alpha = accum[alpha_chan] / IM_SAMPLE_MAX;
      if (alpha) {
	for (ch = 0; ch < alpha_chan; ++ch) {
	  IM_WORK_T val = IM_ROUND(accum[ch] / alpha);
	  pout[ch] = IM_LIMIT(val);
	}
      }
      else {
	for (ch = 0; ch < alpha_chan; ++ch) {
	  /* See RT #32324 (and mention above) */
	  pout[ch] = 0;
	}
      }
      pout[alpha_chan] = IM_LIMIT(IM_ROUND(accum[alpha_chan]));
    }
    else {
      for (ch = 0; ch < channels; ++ch) {
	IM_WORK_T val = IM_ROUND(accum[ch]);
	pout[ch] = IM_LIMIT(val);
      }
    }
  }
}

#/code
