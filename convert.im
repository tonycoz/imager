/*
=head1 NAME

  convert.im - image conversions

=head1 SYNOPSIS

  out = i_convert(srcimage, coeff, outchans, inchans)

=head1 DESCRIPTION

Converts images from one format to another, typically in this case for
converting from RGBA to greyscale and back.

=over

=cut
*/

#define IMAGER_NO_CONTEXT
#include "imager.h"

struct chan_copy {
  /* channels to copy */
  int copy_count;
  int from[MAXTOTALCHANNELS];
  int to[MAXTOTALCHANNELS];

  /* channels to zero */
  int zero_count;
  int zero[MAXTOTALCHANNELS];

  /* channels to set to maxsample */
  int one_count;
  int one[MAXTOTALCHANNELS];
};

static int 
is_channel_copy(i_img *im, const double *coeff, 
		int outchan, int inchan, 
		struct chan_copy *info);

static i_img *
convert_via_copy(i_img *im, i_img *src, struct chan_copy *info);

/* the separate functions here get vectorized, even inlined, while they didn't
   as part of the code
*/

IMAGER_STATIC_INLINE void
vec_add_double(double * restrict out, const i_fsample_t * restrict in, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    out[i] += in[i];
  }
}

#define vec_add_lin_double vec_add_double

IMAGER_STATIC_INLINE void
vec_add_8(double * restrict out, const i_sample_t * restrict in, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    out[i] += in[i];
  }
}

IMAGER_STATIC_INLINE void
vec_add_lin_8(double * restrict out, const i_sample16_t * restrict in, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    out[i] += in[i];
  }
}

IMAGER_STATIC_INLINE void
vec_muladd_double(double * restrict out, const i_fsample_t * restrict in, double coeff, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    out[i] += in[i] * coeff;
  }
}

#define vec_muladd_lin_double vec_muladd_double

IMAGER_STATIC_INLINE void
vec_muladd_8(double * restrict out, const i_sample_t * restrict in, double coeff, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    out[i] += in[i] * coeff;
  }
}

IMAGER_STATIC_INLINE void
vec_muladd_lin_8(double * restrict out, const i_sample16_t * restrict in, double coeff, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    out[i] += in[i] * coeff;
  }
}

IMAGER_STATIC_INLINE void
vec_limit_8(i_sample_t * restrict out, const double * restrict in, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    double val = in[i];
    out[i] = val < 0 ? 0 : val > 255 ? 255 : val;
  }
}

IMAGER_STATIC_INLINE void
vec_limit_lin_8(i_sample16_t * restrict out, const double * restrict in, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    double val = in[i];
    out[i] = val < 0 ? 0 : val > 65535 ? 65535 : val;
  }
}

IMAGER_STATIC_INLINE void
vec_limit_double(i_fsample_t * restrict out, const double * restrict in, size_t count) {
  size_t i;
  for (i = 0; i < count; ++i) {
    double val = in[i];
    out[i] = val < 0 ? 0 : val > 1.0 ? 1.0 : val;
  }
}

#define vec_limit_lin_double vec_limit_double

/*
=item i_convert(src, coeff, outchans, extraoutchans, inchans, linear)

Converts the image src into another image.

coeff contains the co-efficients of an outchan x inchan matrix, for
each output pixel:

              coeff[0], coeff[1] ...
  im[x,y] = [ coeff[inchan], coeff[inchan+1]...        ] * [ src[x,y], 1]
              ...              coeff[inchan*outchan-1]

Now handles images with more than 8-bits/sample.

If C<linear> is a true value, convert correctly using linear samples,
otherwise use the old gamma sample code.

=cut
*/

i_img *
i_convert(i_img *src, const double *coeffs, int outchans, int extraoutchans, int inchans, int linear) {
  i_img_dim x, y;
  int in_ch, out_ch;
  i_img *im = NULL;
  int intotalch = i_img_totalchannels(src);
  int ilimit = inchans > intotalch ? intotalch : inchans;
  int outtotalch = outchans + extraoutchans;
  i_img_dim xmax = src->xsize;
  dIMCTXim(src);

  im_log((aIMCTX,1,"i_convert(im %p, src %p, coeff %p, outchans %d, outextra %d, inchans %d)\n",
	  im, src, coeffs, outchans, extraoutchans, inchans));
 
  im_clear_error(aIMCTX);

  if (outchans < 0 || extraoutchans < 0) {
    im_push_errorf(aIMCTX, 0, "outchans (%d) and extraoutchans (%d) must be non-negative",
                  outchans, extraoutchans);
    return NULL;
  }
  if (outchans == 0 && extraoutchans == 0) {
    im_push_errorf(aIMCTX, 0, "there must be at least one output channel");
    return NULL;
  }

  if (outchans > MAXCHANNELS) {
    im_push_errorf(aIMCTX, 0, "cannot have outchans (%d) > MAXCHANNELS (%d)",
                  outchans, MAXCHANNELS);
    return NULL;
  }

  if (outtotalch > MAXTOTALCHANNELS) {
    im_push_errorf(aIMCTX, 0, "cannot have normal output channels (%d) + extra channels (%d) > maximum total channels (%d)",
                  outchans, extraoutchans, MAXTOTALCHANNELS);
    return NULL;
  }

  if (src->type == i_direct_type || extraoutchans) {
    struct chan_copy info;
    im = i_sametype_chans_extra(src, src->xsize, src->ysize, outchans, extraoutchans);
    
    if (is_channel_copy(src, coeffs, outchans + extraoutchans, inchans, &info)) {
      return convert_via_copy(im, src, &info);
    }
    else {
      if (linear) {
#code src->bits <= i_8_bits
        /* linear version */
        /* allocating individual per channel buffers for input here to
           increase the chance they're equally aligned, increasing the
           chance that auto vectorization can happen.

           Later the mymalloc() calls will be replaced with something
           that returns memory aligned suitable for vectorization *and*
           hopefully tells the compiler that memory is aligned that way.
        */
        IM_LIN_SAMPLE_T *inbufs[MAXTOTALCHANNELS];
        IM_LIN_SAMPLE_T *outbuf = im_aligned_alloc_simd_fatal(sizeof(IM_LIN_SAMPLE_T), im->xsize);
        double *workbuf = im_aligned_alloc_simd_fatal(sizeof(double), im->xsize);

        for (in_ch = 0; in_ch < ilimit; ++in_ch) {
          inbufs[in_ch] = im_aligned_alloc_simd_fatal(sizeof(IM_LIN_SAMPLE_T), im->xsize);
        }

        for (y = 0; y < src->ysize; ++y) {
          for (in_ch = 0; in_ch < ilimit; ++in_ch) {
            IM_GSLIN_ASSERT(src, 0, xmax, y, inbufs[in_ch], &in_ch, 1);
          }
          for (out_ch = 0; out_ch < outtotalch; ++out_ch) {
            for (x = 0; x < xmax; ++x) {
              workbuf[x] = 0;
            }
            for (in_ch = 0; in_ch < ilimit; ++in_ch) {
              double coeff = coeffs[in_ch + inchans * out_ch];
              double *workp = workbuf;
              const IM_LIN_SAMPLE_T * inrow = inbufs[in_ch];
              if (coeff == 0) {
                /* nothing to do */
              }
              else if (coeff == 1.0) {
                IM_SUFFIX(vec_add_lin)(workp, inrow, xmax);
              }
              else {
                IM_SUFFIX(vec_muladd_lin)(workp, inrow, coeff, xmax);
              }
            }
            if (in_ch < inchans) {
              double coeff = coeffs[in_ch + inchans * out_ch];
              if (coeff) {
                for (x = 0; x < xmax; ++x) {
                  workbuf[x] += coeff * IM_LIN_SAMPLE_MAX;
                }
              }
            }
            IM_SUFFIX(vec_limit_lin)(outbuf, workbuf, xmax);
            IM_PSLIN(im, 0, xmax, y, outbuf, &out_ch, 1);
          }
        }
        im_aligned_free(workbuf);
        im_aligned_free(outbuf);
        for (in_ch = 0; in_ch < ilimit; ++in_ch) {
          im_aligned_free(inbufs[in_ch]);
        }
#/code
      }
      else {
#code src->bits <= i_8_bits
        /* gamma version */
        /* allocating individual per channel buffers for input here to
           increase the chance they're equally aligned, increasing the
           chance that auto vectorization can happen.

           Later the mymalloc() calls will be replaced with something
           that returns memory aligned suitable for vectorization *and*
           hopefully tells the compiler that memory is aligned that way.
        */
        IM_SAMPLE_T *inbufs[MAXTOTALCHANNELS];
        IM_SAMPLE_T *outbuf = im_aligned_alloc_simd_fatal(sizeof(IM_SAMPLE_T), im->xsize);
        double *workbuf = im_aligned_alloc_simd_fatal(sizeof(double), im->xsize);

        for (in_ch = 0; in_ch < ilimit; ++in_ch) {
          inbufs[in_ch] = im_aligned_alloc_simd_fatal(sizeof(IM_SAMPLE_T), im->xsize);
        }

        for (y = 0; y < src->ysize; ++y) {
          for (in_ch = 0; in_ch < ilimit; ++in_ch) {
            IM_GSAMP_ASSERT(src, 0, xmax, y, inbufs[in_ch], &in_ch, 1);
          }
          for (out_ch = 0; out_ch < outtotalch; ++out_ch) {
            for (x = 0; x < xmax; ++x) {
              workbuf[x] = 0;
            }
            for (in_ch = 0; in_ch < ilimit; ++in_ch) {
              double coeff = coeffs[in_ch + inchans * out_ch];
              double *workp = workbuf;
              const IM_SAMPLE_T * inrow = inbufs[in_ch];
              if (coeff == 0) {
                /* nothing to do */
              }
              else if (coeff == 1.0) {
                IM_SUFFIX(vec_add)(workp, inrow, xmax);
              }
              else {
                IM_SUFFIX(vec_muladd)(workp, inrow, coeff, xmax);
              }
            }
            if (in_ch < inchans) {
              double coeff = coeffs[in_ch + inchans * out_ch];
              if (coeff) {
                for (x = 0; x < xmax; ++x) {
                  workbuf[x] += coeff * IM_SAMPLE_MAX;
                }
              }
            }
            IM_SUFFIX(vec_limit)(outbuf, workbuf, xmax);
            IM_PSAMP(im, 0, xmax, y, outbuf, &out_ch, 1);
          }
        }
        im_aligned_free(workbuf);
        im_aligned_free(outbuf);
        for (in_ch = 0; in_ch < ilimit; ++in_ch) {
          im_aligned_free(inbufs[in_ch]);
        }
#/code
      }
    }
  }
  else {
    int count;
    int outcount;
    int index;
    i_color *colors;
    i_palidx *vals;
    int i, j;
    double work[MAXCHANNELS];

    im = im_img_pal_new(aIMCTX, src->xsize, src->ysize, outchans, 
			i_maxcolors(src));

    /* just translate the color table */
    count = i_colorcount(src);
    outcount = i_colorcount(im);
    /* color table allocated for image, so it must fit */
    colors = mymalloc(count * sizeof(i_color)); /* check 04Jul05 tonyc */
    i_getcolors(src, 0, colors, count);
    for (index = 0; index < count; ++index) {
      for (j = 0; j < outchans; ++j) {
        work[j] = 0;
        for (i = 0; i < ilimit; ++i) {
          work[j] += coeffs[i+inchans*j] * colors[index].channel[i];
        }
        if (i < inchans) {
          work[j] += coeffs[i+inchans*j] * 255.9;
        }
      }
      for (j = 0; j < outchans; ++j) {
        if (work[j] < 0)
          colors[index].channel[j] = 0;
        else if (work[j] >= 255)
          colors[index].channel[j] = 255;
        else
          colors[index].channel[j] = work[j];
      }
    }
    if (count <= outcount) {
      i_setcolors(im, 0, colors, count);
    }
    else {
      i_setcolors(im, 0, colors, outcount);
      i_addcolors(im, colors, count-outcount);
    }
    /* and copy the indicies */
    /* i_palidx is always unsigned char and will never be bigger than short
       and since a line of 4-byte i_colors can fit then a line of i_palidx
       will fit */
    vals = mymalloc(sizeof(i_palidx) * im->xsize); /* checked 4jul05 tonyc */
    for (y = 0; y < im->ysize; ++y) {
      i_gpal(src, 0, im->xsize, y, vals);
      i_ppal(im, 0, im->xsize, y, vals);
    }
    myfree(vals);
    myfree(colors);
  }

  return im;
}

/*
=item is_channel_copy(coeff, outchan, inchan, chan_copy_info)

Test if the coefficients represent just copying channels around, and
initialize lists of the channels to copy, zero or set to max.

=cut
*/

static
int is_channel_copy(i_img *im, const double *coeff, int outchan, int inchan, 
		    struct chan_copy *info) {
  int srcchan[MAXTOTALCHANNELS];
  int onechan[MAXTOTALCHANNELS];
  int i, j;
  int ilimit = im->channels > inchan ? inchan : im->channels;

  for (j = 0; j < outchan; ++j) {
    srcchan[j] = -1;
    onechan[j] = 0;
  }

  for (j = 0; j < outchan; ++j) {
    for (i = 0; i < ilimit; ++i) {
      if (coeff[i+inchan*j] == 1.0) {
	if (srcchan[j] != -1) {
	  /* from two or more channels, not a copy */
	  return 0;
	}
	srcchan[j] = i;
      }
      else if (coeff[i+inchan*j]) {
	/* some other non-zero value, not a copy */
	return 0;
      }
    }
    if (i < inchan) {
      if (coeff[i+inchan*j] == 1.0) {
	if (srcchan[j] != -1) {
	  /* can't do both */
	  return 0;
	}
	onechan[j] = 1;
      }
      else if (coeff[i+inchan*j]) {
	/* some other non-zero value, not a copy */
	return 0;
      }
    }
  }

  /* build our working data structures */
  info->copy_count = info->zero_count = info->one_count = 0;
  for (j = 0; j < outchan; ++j) {
    if (srcchan[j] != -1) {
      info->from[info->copy_count] = srcchan[j];
      info->to[info->copy_count] = j;
      ++info->copy_count;
    }
    else if (onechan[j]) {
      info->one[info->one_count] = j;
      ++info->one_count;
    }
    else {
      info->zero[info->zero_count] = j;
      ++info->zero_count;
    }
  }

#if 0
  {
    for (i = 0; i < info->copy_count; ++i) {
      printf("From %d to %d\n", info->from[i], info->to[i]);
    }
    for (i = 0; i < info->one_count; ++i) {
      printf("One %d\n", info->one[i]);
    }
    for (i = 0; i < info->zero_count; ++i) {
      printf("Zero %d\n", info->zero[i]);
    }
    fflush(stdout);
  }
#endif

  return 1;
}

/*
=item convert_via_copy(im, src, chan_copy_info)

Perform a convert that only requires channel copies.

=cut
*/

static i_img *
convert_via_copy(i_img *im, i_img *src, struct chan_copy *info) {
#code src->bits <= i_8_bits
  IM_SAMPLE_T *work_samp = mymalloc(sizeof(IM_SAMPLE_T) * src->xsize);
  i_img_dim x, y;
  i_img_dim w = im->xsize;
  int i;

  for (y = 0; y < src->ysize; ++y) {
    for (i = 0; i < info->copy_count; ++i) {
      IM_GSAMP_ASSERT(src, 0, w, y, work_samp, &(info->from[i]), 1);
      IM_PSAMP(im, 0, w, y, work_samp, &(info->to[i]), 1);
    }
    if (info->one_count) {
      for (x = 0; x < w; ++x)
        work_samp[x] = IM_SAMPLE_MAX;
      for (i = 0; i < info->one_count; ++i) {
        IM_PSAMP(im, 0, w, y, work_samp, &(info->one[i]), 1);
      }
    }
    if (info->zero_count) {
      for (x = 0; x < w; ++x)
        work_samp[x] = 0;
      for (i = 0; i < info->zero_count; ++i) {
        IM_PSAMP(im, 0, w, y, work_samp, &(info->zero[i]), 1);
      }
    }
  }
  
  myfree(work_samp);
#/code
      
  return im;
}

/*
=back

=head1 SEE ALSO

Imager(3)

=head1 AUTHOR

Tony Cook <tony@develop-help.com>

=cut
*/
